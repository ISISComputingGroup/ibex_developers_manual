

<!DOCTYPE html>
<html class="writer-html5" lang="en" data-content_root="../../../">
<head>
  <meta charset="utf-8" /><meta name="viewport" content="width=device-width, initial-scale=1" />

  <meta name="viewport" content="width=device-width, initial-scale=1.0" />
  <title>Cryogenic SMS PSU design &mdash; IBEX Developer&#39;s Manual</title>
      <link rel="stylesheet" type="text/css" href="../../../_static/pygments.css?v=b86133f3" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/theme.css?v=9edc463e" />
      <link rel="stylesheet" type="text/css" href="../../../_static/css/custom.css?v=e6a88b47" />

  
    <link rel="shortcut icon" href="../../../_static/favicon.ico"/>
      <script src="../../../_static/jquery.js?v=5d32c60e"></script>
      <script src="../../../_static/_sphinx_javascript_frameworks_compat.js?v=2cd50e6c"></script>
      <script src="../../../_static/documentation_options.js?v=2709fde1"></script>
      <script src="../../../_static/doctools.js?v=fd6eb6e6"></script>
      <script src="../../../_static/sphinx_highlight.js?v=6ffebe34"></script>
    <script src="../../../_static/js/theme.js"></script>
    <link rel="index" title="Index" href="../../../genindex.html" />
    <link rel="search" title="Search" href="../../../search.html" />
    <link rel="next" title="Helium Level Gauge (Cryogenics Ltd)" href="../Cryogenics-Ltd-Helium-Level-Gauge.html" />
    <link rel="prev" title="Cryosms PSU" href="../Cryogenic-SMS-PSU.html" /> 
</head>

<body class="wy-body-for-nav"> 
  <div class="wy-grid-for-nav">
    <nav data-toggle="wy-nav-shift" class="wy-nav-side">
      <div class="wy-side-scroll">
        <div class="wy-side-nav-search"  style="background: #343131" >

          
          
          <a href="../../../index.html" class="icon icon-home">
            IBEX Developer's Manual
              <img src="../../../_static/logo.svg" class="logo" alt="Logo"/>
          </a>
<div role="search">
  <form id="rtd-search-form" class="wy-form" action="../../../search.html" method="get">
    <input type="text" name="q" placeholder="Search docs" aria-label="Search docs" />
    <input type="hidden" name="check_keywords" value="yes" />
    <input type="hidden" name="area" value="default" />
  </form>
</div>
        </div><div class="wy-menu wy-menu-vertical" data-spy="affix" role="navigation" aria-label="Navigation menu">
              <p class="caption" role="heading"><span class="caption-text">Overview</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Overview.html">Project Overview</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Editing-the-Wiki.html">Editing this Documentation</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Glossary.html">Glossary</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">User Interfaces &amp; Scripting</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Client.html">IBEX GUI (Eclipse)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Script-Generator.html">Script Generator</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Scripting.html">Scripting (Python)</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Web.html">Web Dashboard &amp; Chat</a></li>
</ul>
<p class="caption" role="heading"><span class="caption-text">IBEX Server &amp; Systems</span></p>
<ul class="current">
<li class="toctree-l1"><a class="reference internal" href="../../../System-components.html">Backend System Components</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../IOCs.html">EPICS IOCs &amp; Support Modules</a></li>
<li class="toctree-l1 current"><a class="reference internal" href="../../../Specific-IOCs.html">Specific Devices &amp; IOCs</a><ul class="current">
<li class="toctree-l2"><a class="reference internal" href="../../Cells.html">Cells</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Choppers.html">Choppers</a></li>
<li class="toctree-l2 current"><a class="reference internal" href="../../Cryogenics.html">Cryogenics</a><ul class="current">
<li class="toctree-l3"><a class="reference internal" href="../2T-3D-Vector-magnet.html">Scientific Magnetics 2T 3D Vector Magnet</a></li>
<li class="toctree-l3"><a class="reference internal" href="../CP2800-Compressors.html">CP2800 Compressors</a></li>
<li class="toctree-l3 current"><a class="reference internal" href="../Cryogenic-SMS-PSU.html">Cryosms PSU</a><ul class="current">
<li class="toctree-l4 current"><a class="current reference internal" href="#">Cryogenic SMS PSU design</a></li>
</ul>
</li>
<li class="toctree-l3"><a class="reference internal" href="../Cryogenics-Ltd-Helium-Level-Gauge.html">Helium Level Gauge (Cryogenics Ltd)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../HLM-General.html">Helium Level Monitoring</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ICE-Dilution-Fridge.html">ICE Dilution Fridge</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ITC-503.html">ITC503</a></li>
<li class="toctree-l3"><a class="reference internal" href="../ITC503-Heliox.html">ITC503 (Old-style Heliox)</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Mercury-Heliox.html">Oxford Instruments Mercury Heliox</a></li>
<li class="toctree-l3"><a class="reference internal" href="../MercuryiTC.html">Mercury iTC</a></li>
<li class="toctree-l3"><a class="reference internal" href="../MercuryiTC-Enhanced-Cryostat-Control.html">Mercury iTC - Enhanced cryostat control</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Oxford-Instruments-IPS.html">IPS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Oxford-Instruments-Mercury-IPS.html">Mercury IPS</a></li>
<li class="toctree-l3"><a class="reference internal" href="../Triton.html">Triton</a></li>
</ul>
</li>
<li class="toctree-l2"><a class="reference internal" href="../../DAE-and-the-ICP.html">DAE (Data Acquisition Electronics)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../DAQ.html">DAQ (NI cDAQ)</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Datastreaming.html">Data Streaming</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Fluxgates.html">Fluxgates &amp; Magnetometers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Gas-And-Liquid-Handling-Systems.html">Gas and liquid handling systems</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Imaging-Cameras.html">Imaging Cameras</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Loading-Rigs.html">Loading rigs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Magnets.html">Magnets &amp; Large Power Supplies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Motors.html">Motors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Motors-Extensions.html">Motor Extensions</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Multimeters.html">Multimeters</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Other.html">Other / Miscellaneous</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../PLCs.html">PLCs</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Polarisers-and-Analysers.html">Polarisers &amp; Analysers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Power-Distribution-Unit-%28PDU%29.html">Power distribution units</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Power-Supplies.html">Power supplies</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Pressure-Monitors.html">Pressure monitors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Reflectometry-IOC.html">Reflectometry</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Rheometers.html">Rheometers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Sample-Changers.html">Sample Changers</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Sensors.html">Sensors</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Signal-Generators.html">Signal Generators</a></li>
<li class="toctree-l2"><a class="reference internal" href="../../Temperature-Controllers.html">Temperature Controllers</a></li>
</ul>
</li>
</ul>
<p class="caption" role="heading"><span class="caption-text">Project Processes &amp; Tools</span></p>
<ul>
<li class="toctree-l1"><a class="reference internal" href="../../../Providing-Support.html">Providing Support</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Deployment.html">Releases &amp; Deployment</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Tools.html">Tools</a></li>
<li class="toctree-l1"><a class="reference internal" href="../../../Processes.html">Processes</a></li>
</ul>

        </div>
      </div>
    </nav>

    <section data-toggle="wy-nav-shift" class="wy-nav-content-wrap"><nav class="wy-nav-top" aria-label="Mobile navigation menu"  style="background: #343131" >
          <i data-toggle="wy-nav-top" class="fa fa-bars"></i>
          <a href="../../../index.html">IBEX Developer's Manual</a>
      </nav>

      <div class="wy-nav-content">
        <div class="rst-content">
          <div role="navigation" aria-label="Page navigation">
  <ul class="wy-breadcrumbs">
      <li><a href="../../../index.html" class="icon icon-home" aria-label="Home"></a></li>
          <li class="breadcrumb-item"><a href="../../../Specific-IOCs.html">Specific Devices &amp; IOCs</a></li>
          <li class="breadcrumb-item"><a href="../../Cryogenics.html">Cryogenics</a></li>
          <li class="breadcrumb-item"><a href="../Cryogenic-SMS-PSU.html">Cryosms PSU</a></li>
      <li class="breadcrumb-item active">Cryogenic SMS PSU design</li>
      <li class="wy-breadcrumbs-aside">
              <a href="https://github.com/ISISComputingGroup/ibex_developers_manual/blob/master/doc/specific_iocs/cryogenics/cryosms/Cryogenic-SMS-PSU-design.md" class="fa fa-github"> Edit on GitHub</a>
      </li>
  </ul>
  <hr/>
</div>
          <div role="main" class="document" itemscope="itemscope" itemtype="http://schema.org/Article">
           <div itemprop="articleBody">
             
  <section class="tex2jax_ignore mathjax_ignore" id="cryogenic-sms-psu-design">
<h1>Cryogenic SMS PSU design<a class="headerlink" href="#cryogenic-sms-psu-design" title="Link to this heading"></a></h1>
<section id="requirements">
<h2>Requirements<a class="headerlink" href="#requirements" title="Link to this heading"></a></h2>
<p>These are used to power the HIFI Cryomag. There are four, one (higher max current) controls the main switched cryomagnet, the other three (lower max current) control the X, Y, and Z ‘shim’ coil magnets. They are capable of driving the main cryomagnet up to a field of ~4.9 Tesla.</p>
<p>Magnet cool downs typically take several days, warm ups take a similar length of time. It usually sits at 3-4K, the temperature is monitored by a Keithley 2700.</p>
<p>They are connected via USB to serial RS-232 directly to the NDXHIFI_CRYOMAG PC.</p>
<p>All commands have a longhand and a shorthand version which can be found in the manual on our network share. The emulator has been made such that it can deal with the longhand or the shorthand, since it must be tested against the VI for compatibility, and the VI uses shorthand commands (vs the IOC which uses longhand).</p>
<p>Commands can reply with a myriad of options. Some of these are time stamped, some are not. These are also listed in the manual on the network share.</p>
</section>
<section id="ioc-structure">
<h2>IOC Structure<a class="headerlink" href="#ioc-structure" title="Link to this heading"></a></h2>
<p>The IOC itself has multiple layers. On the surface, there is an EPICS db file with some values
populated by <code class="docutils literal notranslate"><span class="pre">get</span></code> commands in a stream device proto file, some setpoints that eventually lead
to <code class="docutils literal notranslate"><span class="pre">set</span></code> commands in that same proto, and a series of calc records. These PVs are the ones the
OPI reads and writes to. For basic interactions, this is all you need to know.</p>
<p>However, behind the scenes you may notice that many of the user-facing setpoints don’t actually
directly write out anywhere, and the ones that do are not exposed to users via the OPI, and also
don’t seem to be written to/triggered from anywhere in the db. This is because there is a driver
in <code class="docutils literal notranslate"><span class="pre">CRYOSMSDriver.cpp</span></code> built off of asynPortDriver (hereafter referred to as “the driver”)
sitting on top of the IOC, which is looking at what the user is setting and  what the device is
currently doing, then writing out to relevant “hidden” setpoints (<code class="docutils literal notranslate"><span class="pre">:_SP</span></code> rather than <code class="docutils literal notranslate"><span class="pre">:SP</span></code>).
This allows it to get the device to an end-state the user wants without them having to know
about all the intermediate steps needed to get there, and also making sure the magnet doesn’t
quench.</p>
<p>Attached to the driver is a queued state machine, implemented with a thread that
decides when to pop events from a queue to an implementation of boost’s meta state machine. This
part of the system is mostly just to ensure all the reads, writes, waits, etc. happen
consistently and in the right order.</p>
<p>Safety is the number one concern of this system, and if there appears to be an overly
complicated implementation for something, chances are that if it wasn’t there it could lead to
a magnet quench. This needs to happen at IOC level because the PSU itself will happily quench
the magnet if you give it the wrong commands.</p>
</section>
<section id="initialisation">
<h2>Initialisation<a class="headerlink" href="#initialisation" title="Link to this heading"></a></h2>
<section id="macros">
<h3>Macros<a class="headerlink" href="#macros" title="Link to this heading"></a></h3>
<p>The IOC has the following macros. A small number (e.g. T_TO_A) are used by the db, but the
majority are only used by the driver. At the bottom of the main file, you can see them
being loaded via the usual method for an asynPortDriver. Upon initialising the driver,
these values are loaded into a map of the form <code class="docutils literal notranslate"><span class="pre">MACRO_NAME:</span> <span class="pre">[macro_value]</span></code> called <code class="docutils literal notranslate"><span class="pre">envVarMap</span></code>, which
other methods reference whenever they need to check a macro.</p>
<table class="docutils align-default">
<thead>
<tr class="row-odd"><th class="head"><p>Macro</p></th>
<th class="head"><p>Description</p></th>
<th class="head"><p>Defaults</p></th>
</tr>
</thead>
<tbody>
<tr class="row-even"><td><p>MAX_CURR</p></td>
<td><p>Define the maximum current that is allowed</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>T_TO_A</p></td>
<td><p>The conversion value between Tesla and Amps for the system</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>MAX_VOLT</p></td>
<td><p>Set the maximum voltage for the system</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>WRITE_UNIT</p></td>
<td><p>Which unit to write to the PSU in</p></td>
<td><p>Amps</p></td>
</tr>
<tr class="row-even"><td><p>WRITE_UNIT_TIMEOUT</p></td>
<td><p>How long in seconds to wait after write unit is  changed before resetting it to <code class="docutils literal notranslate"><span class="pre">WRITE_UNIT</span></code></p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>DISPLAY_UNIT</p></td>
<td><p>Which unit will be used when displaying the value from the PSU</p></td>
<td><p>Gauss</p></td>
</tr>
<tr class="row-even"><td><p>RAMP_FILE</p></td>
<td><p>Location of file containing ramp rates</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>ALLOW_PERSIST</p></td>
<td><p>Whether or not to allow setting of persistent values</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>USE_SWITCH</p></td>
<td><p>Whether or not to monitor and set switches on and off</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-odd"><td><p>SWITCH_TEMP_PV</p></td>
<td><p>PV address of switch temperature</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>SWITCH_HIGH</p></td>
<td><p>The value at which the switch will be considered warm</p></td>
<td><p>3.7</p></td>
</tr>
<tr class="row-odd"><td><p>SWITCH_LOW</p></td>
<td><p>The value at which the switch will be considered cold</p></td>
<td><p>3.65</p></td>
</tr>
<tr class="row-even"><td><p>SWITCH_STABLE_NUMBER</p></td>
<td><p>The number of readings past a threshold needed before the switch can be considered warm/cold</p></td>
<td><p>10</p></td>
</tr>
<tr class="row-odd"><td><p>HEATER_TOLERANCE</p></td>
<td><p>The tolerance between the magnet and lead currents before considering them as close enough to allow the leads to warm</p></td>
<td><p>0.2</p></td>
</tr>
<tr class="row-even"><td><p>SWITCH_TIMEOUT</p></td>
<td><p>The time to allow for the switch to warm or cold after turning the heater on/off before considering there to be an error situation</p></td>
<td><p>300</p></td>
</tr>
<tr class="row-odd"><td><p>SWITCH_TEMP_TOLERANCE</p></td>
<td><p>needs clarification</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>HEATER_OUT</p></td>
<td><p>The heater output to be used</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>USE_MAGNET_TEMP</p></td>
<td><p>Whether to act if the Magnet Temperature is out of range</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>MAGNET_TEMP_PV</p></td>
<td><p>The PV address of the magnet temperature</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>MAX_MAGNET_TEMP</p></td>
<td><p>Maximum allowed temperature of magnet</p></td>
<td><p>5.5</p></td>
</tr>
<tr class="row-even"><td><p>MIN_MAGNET_TEMP</p></td>
<td><p>Temperature below which there is potentially an error reading temperature from the magnet</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-odd"><td><p>COMP_OFF_ACT</p></td>
<td><p>Whether to act if magnet temperature is out of range</p></td>
<td><p>No</p></td>
</tr>
<tr class="row-even"><td><p>NO_OF_COMP</p></td>
<td><p>Number of compressors in the system</p></td>
<td><p>2</p></td>
</tr>
<tr class="row-odd"><td><p>COMP_1_STAT_PV</p></td>
<td><p>The PV address for the status of the first compressor</p></td>
<td><p></p></td>
</tr>
<tr class="row-even"><td><p>COMP_2_STAT_PV</p></td>
<td><p>The PV address for the status of the second compressor</p></td>
<td><p></p></td>
</tr>
<tr class="row-odd"><td><p>FAST_RATE</p></td>
<td><p>The ramp rate to use for the fast ramps</p></td>
<td><p>0.5</p></td>
</tr>
<tr class="row-even"><td><p>FAST_PERSISTENT_SETTLETIME</p></td>
<td><p>The number of seconds to settle after a ramp fast to persist</p></td>
<td><p>5</p></td>
</tr>
<tr class="row-odd"><td><p>PERSISTENT_SETTLETIME</p></td>
<td><p>The number of seconds to settle after a ramp to persist</p></td>
<td><p>60</p></td>
</tr>
<tr class="row-even"><td><p>FILTER_VALUE</p></td>
<td><p>The value to use to filter the target reached calculation</p></td>
<td><p>0.1</p></td>
</tr>
<tr class="row-odd"><td><p>FAST_FILTER_VALUE</p></td>
<td><p>The value to use to filter the target reached calculation when ramping fast to a target</p></td>
<td><p>1</p></td>
</tr>
<tr class="row-even"><td><p>NPP</p></td>
<td><p>The npp value when calculating whether or not the target has been reached</p></td>
<td><p></p></td>
</tr>
</tbody>
</table>
</section>
<section id="startup-checks">
<h3>Startup Checks<a class="headerlink" href="#startup-checks" title="Link to this heading"></a></h3>
<p>As some of the checks needed to be run upon initialisation are only possible after the db has
initialised, they are run in the <code class="docutils literal notranslate"><span class="pre">onStart()</span></code> method that only runs when the <code class="docutils literal notranslate"><span class="pre">INIT</span></code> PV (with
<code class="docutils literal notranslate"><span class="pre">PINI</span></code> 1) writes out. This method checks various macros to determine whether certain modes of
operation should be enabled/disabled:</p>
<p>All writes to the device will be disabled in any of these situations:</p>
<ul class="simple">
<li><p><code class="docutils literal notranslate"><span class="pre">T_TO_A</span></code> not supplied and <code class="docutils literal notranslate"><span class="pre">CRYOMAGNET</span></code> is <code class="docutils literal notranslate"><span class="pre">Yes</span></code></p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">MAX_CURR</span></code> not supplied</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">ALLOW_PERSIST</span></code> is on, but any of the subsequently required variables (<code class="docutils literal notranslate"><span class="pre">FAST_FILTER_VALUE,</span> <span class="pre">FILTER_VALUE,</span> <span class="pre">NPP,</span> <span class="pre">FAST_PERSISTENT_SETTLETIME,</span> <span class="pre">FAST_RATE</span></code>) are missing</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">USE_SWITCH</span></code> is on, but any of the subsequently required variables (<code class="docutils literal notranslate"><span class="pre">SWITCH_TEMP_PV,</span> <span class="pre">SWITHCH_HIGH,</span> <span class="pre">SWITCH_LOW,</span> <span class="pre">SWITCH_STABLE_NUMBER,</span> <span class="pre">HEATER_TOLERANCE,</span> <span class="pre">SWITCH_TIMEOUT,</span> <span class="pre">SWITCH_TEMP_TOLERANCE,</span> <span class="pre">HEATER_OUT</span></code>) are missing</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">USE_MAGNET_TEMP</span></code> is on, but any of the subsequently required variables (<code class="docutils literal notranslate"><span class="pre">MAGNET_TEMP_PV,</span> <span class="pre">MAX_MAGNET_TEMP,</span> <span class="pre">MIN_MAGNET_TEMP</span></code>) are missing</p></li>
<li><p><code class="docutils literal notranslate"><span class="pre">COMP_OFF_ACT</span></code> is on, but any of the subsequently required variables (<code class="docutils literal notranslate"><span class="pre">NO_OF_COMP,</span> <span class="pre">MIN_NO_OF_COMP,</span> <span class="pre">COMP_1_STAT_PV,</span> <span class="pre">COMP_2_STAT_PV</span></code>) are missing</p></li>
</ul>
<p>Additionally, the driver will initialise various variables and send several commands to the
PSU based on user provided macros:</p>
<ul class="simple">
<li><p>The Tesla-Amps conversion rate will be set to <code class="docutils literal notranslate"><span class="pre">T_TO_A</span></code> if <code class="docutils literal notranslate"><span class="pre">CRYOMAGNET</span></code> is set to <code class="docutils literal notranslate"><span class="pre">Yes</span></code></p></li>
<li><p>The maximum allowed current will be set to <code class="docutils literal notranslate"><span class="pre">MAX_CURR</span></code></p></li>
<li><p>The maximum allowed voltage will be set to <code class="docutils literal notranslate"><span class="pre">MAX_VOLT</span></code></p></li>
<li><p>The heater output will be set to <code class="docutils literal notranslate"><span class="pre">HEATER_OUT</span></code></p></li>
<li><p>The file named in <code class="docutils literal notranslate"><span class="pre">RAMP_FILE</span></code> will be used to populate a ramp table, consisting of values for
the fastest safe ramp within a field range, and the maximum field strength of that range.</p>
<ul>
<li><p>More info on ramp rates in <a class="reference internal" href="#performing-a-ramp">Performing a Ramp</a></p></li>
</ul>
</li>
<li><p>The ramp rate will be set to an appropriate value read from the ramp table based on the current
value of the field</p></li>
<li><p>Finally, a thread containing the event queue, a thread which continually checks certain values,
and the meta state machine are all started</p></li>
</ul>
<p>If no errors occur throughout this process, it will then write 1 back to <code class="docutils literal notranslate"><span class="pre">INIT</span></code>, which will show
as “Startup complete”. If the IOC doesn’t seem to be starting correctly, check this PV to figure
out if you need to debug whether/where <code class="docutils literal notranslate"><span class="pre">onStart()</span></code> is hitting an error.</p>
</section>
</section>
<section id="unit-conversion">
<h2>Unit Conversion<a class="headerlink" href="#unit-conversion" title="Link to this heading"></a></h2>
<p>The PSU defaults to displaying, and sending/receiving via its USB interface, the values for
current it is outputting to the coils in terms of Amps. It can, however, also output the field
strength in Tesla that will be achieved for a given current if it is provided with a conversion
factor from current to field strength. This conversion factor will likely vary from magnet to
magnet as it is determined by the geometry, material properties, etc. of the magnet itself. We
tell the PSU which to display on its front panel and use for communication through the
<code class="docutils literal notranslate"><span class="pre">OUTPUTMODE:_SP</span></code> PV based on <code class="docutils literal notranslate"><span class="pre">WRITE_UNIT</span></code>.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The shim magnets on HIFI are  also operated using these PSUs and this IOC, however the
Tesla-Amps conversion factor is far outside what the PSU considers a valid range (as these are
not cryomagnets). For these, we set <code class="docutils literal notranslate"><span class="pre">CRYOMAGNET</span></code> to “No”, to tell our IOC not to even try
writing <code class="docutils literal notranslate"><span class="pre">T_TO_A</span></code> to the PSU. Instead, we only read/write in Amps and perform all conversions in
the IOC.</p>
</div>
<p>Users additionally often wish to have the PSU output shown as the resulting field strength in
Gauss (10,000 Gauss = 1 Tesla), which is set to be the default value displayed. In order to convert
between values read from the device, you will see several calcs in the db converting from
<code class="docutils literal notranslate"><span class="pre">[value]:RAW</span></code>, which will be in <code class="docutils literal notranslate"><span class="pre">WRITE_UNIT</span></code>, to <code class="docutils literal notranslate"><span class="pre">[value]:AMPS</span></code>, <code class="docutils literal notranslate"><span class="pre">[value]:FIELD:TESLA</span></code>, and <code class="docutils literal notranslate"><span class="pre">[value]</span> <span class="pre">:FIELD:GAUSS</span></code> before finally the user-facing <code class="docutils literal notranslate"><span class="pre">[value]</span></code> selects which of these to use based on
<code class="docutils literal notranslate"><span class="pre">DISPLAY_UNIT</span></code>.</p>
<p>In the driver meanwhile, values that are read from user-facing PVs in the db are taken
to be supplied in terms of <code class="docutils literal notranslate"><span class="pre">DISPLAY_UNIT</span></code>, and are converted back and forth between values based on
need for certain calculations, before being sent to the device in <code class="docutils literal notranslate"><span class="pre">WRITE_UNIT</span></code>.</p>
<p>Instrument scientists also wished to be able to temporarily change <code class="docutils literal notranslate"><span class="pre">WRITE_UNIT</span></code> for use cases
which were never made clear (as of the author Lilith’s memory in Nov 2025, this may be so that
they can tinker with values physically on the PSU?). Nonetheless, this functionality is
available to them. The PV <code class="docutils literal notranslate"><span class="pre">OUTPUTMODE:SP</span></code> lets users change the write unit for a time period set
by <code class="docutils literal notranslate"><span class="pre">WRITE_UNIT_TIMEOUT</span></code>, which is propagated through the driver by changing the value
mapped in <code class="docutils literal notranslate"><span class="pre">envVarMap</span></code> before writing to the device using <code class="docutils literal notranslate"><span class="pre">OUTPUTMODE:_SP</span></code>. At the end of the
macro-defined timeout, the checks thread will automatically change everything back to the
<code class="docutils literal notranslate"><span class="pre">WRITE_UNIT</span></code> specified by macros.</p>
</section>
<section id="event-queue">
<h2>Event Queue<a class="headerlink" href="#event-queue" title="Link to this heading"></a></h2>
<p>The event queue is a double-ended queue which is used to queue up state transitions to be
performed on the state machine. It is processed in a while loop on the <code class="docutils literal notranslate"><span class="pre">eventQueueThread</span></code>, which
determines when to pop an event and push it to the state machine based on factors that vary by
whichever state the state machine is currently in (for example, making sure the PSU is at a ramp
target before leaving the “ramping” state). Throughout the driver, events are pushed to either
end of this queue (usually the back) by various methods.
Within this queue, individual events are stored inside  variant objects from the boost variant
library in order to preserve typing (boost msm fires events based on the typing of the object
being passed to it).</p>
</section>
<section id="queued-state-machine">
<h2>Queued State Machine<a class="headerlink" href="#queued-state-machine" title="Link to this heading"></a></h2>
<p>The IOC makes use of a queued state machine, based upon the meta state machine library from
boost. This is stored in a separate file from the driver, <code class="docutils literal notranslate"><span class="pre">QueuedStateMachine.h</span></code>, as it is
header-based.
Here, possible states, events (things that prompt state changes) and actions (code to perform on
given state transitions) are defined, alongside a table of possible transitions and the
respective actions to process when performing them.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>To avoid a circular dependency, the state machine imports a dummy version of the main driver,
defined in <code class="docutils literal notranslate"><span class="pre">StateMachineDriver.h</span></code>, which the main driver inherits from and then overloads the
methods of.</p>
</div>
</section>
<section id="sets-sent-to-the-driver">
<h2>Sets Sent to the Driver<a class="headerlink" href="#sets-sent-to-the-driver" title="Link to this heading"></a></h2>
<p>As most of the values used by the driver are read directly by it from the db, there are only a
handful of PVs that actually send values to the driver themselves:</p>
<section id="output-mode">
<h3>Output Mode<a class="headerlink" href="#output-mode" title="Link to this heading"></a></h3>
<p>As described in <a class="reference internal" href="#unit-conversion">Unit Conversion</a>, temporarily tells the PSU to communicate in
different units.</p>
</section>
<section id="init">
<h3>Init<a class="headerlink" href="#init" title="Link to this heading"></a></h3>
<p>Starts the initialisation process described in <a class="reference internal" href="#startup-checks">Startup Checks</a>. This only
happens once per boot.</p>
</section>
<section id="heater-response-deconstruction">
<h3>Heater response deconstruction<a class="headerlink" href="#heater-response-deconstruction" title="Link to this heading"></a></h3>
<p>The PSU’s reply to asking whether the magnet heater is on can get complicated, so it is sent to
c++ to be dealt with instead of using stream device (It’s possible that this could all be done
in stream device, and if you want to do this, by all means make a ticket).</p>
<p>The response is of the form <code class="docutils literal notranslate"><span class="pre">HEATER</span> <span class="pre">STATUS:</span> <span class="pre">{OFF|ON}</span></code> if it is either on or off with the magnet
at 0T, or <code class="docutils literal notranslate"><span class="pre">HEATER</span> <span class="pre">STATUS:</span> <span class="pre">OFF</span> <span class="pre">AT</span> <span class="pre">{value}</span> <span class="pre">{units}</span></code> if it is off with the magnet holding a field
of <code class="docutils literal notranslate"><span class="pre">{value}</span></code> in units of <code class="docutils literal notranslate"><span class="pre">{units}</span></code>. This is then filtered through to relevant heater readback
and <code class="docutils literal notranslate"><span class="pre">OUTPUT:PERSIST</span></code> PVs. The PV <code class="docutils literal notranslate"><span class="pre">OUTPUT:COIL</span></code> then switches which pv it reads from based on
whether the heater is on or off (on - <code class="docutils literal notranslate"><span class="pre">OUTPUT</span></code>, technically the current through the magnet’s
leads; off - <code class="docutils literal notranslate"><span class="pre">OUTPUT:PERSIST</span></code>), as it represents the definitive value of the magnet’s output.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>If the heater is off and the magnet has current running through it, this means that is in
superconducting or “persistent” mode. If you ramp the current in the leads away from this (e.g.
to 0 if the  user selects to ramp leads to 0 after ramping the magnet), the leads MUST be ramped
back to the persistent current before switching the heater back on, else the magnet will quench
as the previously superconducting current rapidly changes to meet the current through the leads.</p>
</div>
</section>
<section id="start">
<h3>Start<a class="headerlink" href="#start" title="Link to this heading"></a></h3>
<p>Tells the driver to perform a ramp based on settings provided to other PVs. See <a class="reference internal" href="#performing-a-ramp">Performing a
Ramp</a></p>
</section>
<section id="pause">
<h3>Pause<a class="headerlink" href="#pause" title="Link to this heading"></a></h3>
<p>Setting this to 1 pushes a “pause” event to the state machine, then suspends the event queue
thread. If the PSU is ramping, the “pause” event will tell it to pause, and will put the state
machine into the paused state which can only be left by resuming or aborting.<br />
Immediately responds with an “acknowledge” message.</p>
<p>Setting this to 0 will place a “resume” event at the front of the event queue, then restart the
event queue thread to immediately process it, putting the state machine back into a ramping state.
The ramp will then continue as before.</p>
</section>
<section id="abort">
<h3>Abort<a class="headerlink" href="#abort" title="Link to this heading"></a></h3>
<p>Similar to Pause, when abort is set to 1 it will process an “abort” event immediately, however
it will not suspend the state machine. It will then attempt to stop any warming or cooling by
queuing a “cool” or “warm” respectively. If the PSU was instead ramping, it will pause the ramp,
set the PSU ramp endpoint to the current output, empty the rest of the event queue, then resume
so that the PSU immediately accepts that the ramp has reached its target at its current output.</p>
</section>
</section>
<section id="performing-a-ramp">
<h2>Performing a Ramp<a class="headerlink" href="#performing-a-ramp" title="Link to this heading"></a></h2>
<p>When <a class="reference internal" href="#start">Start</a> is processed, the driver will attempt to construct a queue of state
transitions in the event queue which will make the properties of the magnet be what the user has
specified. this is done by the method <code class="docutils literal notranslate"><span class="pre">setupRamp()</span></code></p>
<p>First, the driver checks whether the magnet is currently in persistent mode. If it is, it will
queue a fast ramp of the leads to bring them to the persistent current if this is needed, then
it will warm the magnet up to take it out of persistent mode.</p>
<div class="admonition note">
<p class="admonition-title">Note</p>
<p>The leads can be ramped much faster than the coils, so a separate ramp rate set by the
macro <code class="docutils literal notranslate"><span class="pre">FAST_RATE</span></code> is used when ramping only them.</p>
</div>
<p>Next, the driver will take the current field strength in the magnet as the start point and the
desired field strength set in <code class="docutils literal notranslate"><span class="pre">OUTPUT:SP</span></code> as the end point. It will then compare these points to
the ranges of field strengths in the ramp table. If both are within the same range (and same
polarity, more on that later), it will simply queue a ramp event set to the end point at the
relevant ramp rate for that range, then a “target reached” event. If however, the start and end
points are in different field ranges in the ramp table, it will queue up ramp events to each of the
field range maxima, at ramp rates that correspond to the ranges that each ramp will be going
through, in the order that the maxima will be encountered in on the route between the start and
end point. After each of these individual ramp events, it will also queue a “target reached”
event for immediately after it.</p>
<p>In the cases where the start point and end point have opposite polarities, the above process
will be performed first by going from the start to 0, then from 0 up to the end point.</p>
<p>Finally, the driver will queue a cool-down event if the user wants the magnet to be persisting at
the end point, and will ram the leads to 0 if the user wants that to happen also.</p>
<section id="ramp-events">
<h3>Ramp Events<a class="headerlink" href="#ramp-events" title="Link to this heading"></a></h3>
<p>Ramps are passed to the state machine with four values:</p>
<ul class="simple">
<li><p>their endpoint</p></li>
<li><p>the ramp rate to use to get the endpoint</p></li>
<li><p>the polarity of the endpoint (only needed when going from 0)</p></li>
<li><p>ramp type (e.g. whether this is a fast ramp of the leads)</p></li>
</ul>
<p>When processed, the driver will set the PSU’s output midpoint (in the context of
0 - arbitrary midpoint - max; midpoint doesn’t have to be half of max and rarely is) and its
ramp rate, then tell it to ramp to the midpoint. If a ramp’s start point is 0, it will first
make sure the polarity set on the PSU is the same as the endpoint’s polarity.</p>
<p>After being processed, the event queue thread will wait until the PSU’s output is within a
tolerance of the ramp’s endpoint and the PSU is reporting that it is holding at target, then
process the target reached event.</p>
</section>
<section id="target-reached-events">
<h3>Target Reached Events<a class="headerlink" href="#target-reached-events" title="Link to this heading"></a></h3>
<p>The events which are queued after each ramp mostly exist to better delineate between ramps in
the state machine. The other function of them is that they  will each check if the en point
their individual ramp reached is the end point specified by the user - the final end point. If
it is, they will make the driver wait for a period of time specified by relevant hold/settle<br />
time macros before letting it carry on with any further events.</p>
</section>
</section>
<section id="statuses">
<h2>Statuses<a class="headerlink" href="#statuses" title="Link to this heading"></a></h2>
<p>There are a variety of statuses that can be put to the <code class="docutils literal notranslate"><span class="pre">STAT</span></code> pv. Some of them contain extra
contextual messages, but broadly there are the following cases:</p>
<ul class="simple">
<li><p>Ready - The driver and PSU both are not currently doing anything, and are ready for user inputs</p></li>
<li><p>Ramping - The PSU is ramping its output</p></li>
<li><p>Paused - Either the user or an internal check has caused a ramp to pause</p></li>
<li><p>Holding/Settling - The PSU claims to have finished what it was doing, the driver is waiting
for things to settle briefly before it either goes into ready or starts its next task</p></li>
<li><p>Cooling/Warming - The heater has recently been switched off or on,  we are waiting until its
temperature is consistently below/above <code class="docutils literal notranslate"><span class="pre">SWITCH_LOW</span></code> or <code class="docutils literal notranslate"><span class="pre">SWITCH_HIGH</span></code> respectively</p></li>
<li><p>Aborting - Something has caused the driver to abort, it is in the process of stopping everything</p></li>
<li><p>Processing - The driver only goes into this status when it can no longer say that its previous
status is valid, but it has yet to achieve a subsequent status. For example, when <code class="docutils literal notranslate"><span class="pre">START:SP</span></code>
is set, it goes from Ready to Processing, then goes to Ramping once the first ramp has started.
If the driver is reporting this status for a long time, it means something has gone wrong in
its queue somewhere and it needs restarting</p></li>
</ul>
<section id="the-ready-pv">
<h3>The READY PV<a class="headerlink" href="#the-ready-pv" title="Link to this heading"></a></h3>
<p>The <code class="docutils literal notranslate"><span class="pre">READY</span></code> PV is simply a boolean pv that  simplifies the <code class="docutils literal notranslate"><span class="pre">STAT</span></code> PV. Either the driver is ready,
and can accept commands, or it is not.</p>
</section>
</section>
<section id="automatic-pausing-aborting">
<h2>Automatic Pausing/ Aborting<a class="headerlink" href="#automatic-pausing-aborting" title="Link to this heading"></a></h2>
<p>The “checks” thread created during <a class="reference internal" href="#startup-checks">startup checks</a> will run through its loop
twice per second, decrementing/checking against any ongoing timers, pausing the ramps for safety if
not enough compressors are active, and checking for quenches.</p>
<section id="quenches">
<h3>Quenches<a class="headerlink" href="#quenches" title="Link to this heading"></a></h3>
<p>The magnet can quench if it is ramped too aggressively, or if its temperature drifts too high.
If the PSU detects a quench, it reports that it thinks the magnet has quenched. The IOC will
interpret this and halt all queued actions. It will stay in this state until the IOC is restarted.</p>
<div class="admonition important">
<p class="admonition-title">Important</p>
<p>The PSU lacks any safety measures to prevent you from ordering it to perform actions that will
quench a magnet. It will happily turn on the heater when the magnet is at 10T and the leads are
at 0. This is why the driver is so careful about everything it sends</p>
</div>
</section>
</section>
<section id="behind-the-scenes-pvs">
<h2>Behind the scenes PVs<a class="headerlink" href="#behind-the-scenes-pvs" title="Link to this heading"></a></h2>
<p>When the driver sends a value to the PSU, it does so by setting a relevant PV ending in <code class="docutils literal notranslate"><span class="pre">:_SP</span></code>,
which then sends a command to the PSU via stream device. This does mean that there are all sorts
of PVs which can be tinkered with to sidestep the driver and manually define/start ramps or
toggle the heater. Yes, you can use these if you really want to, but only do so if you are
absolutely sure you’re not quenching the magnet. That cumbersome driver is there for a reason.</p>
</section>
<section id="other-iocs-that-interface-with-cryosms">
<h2>Other IOCs that Interface with CRYOSMS<a class="headerlink" href="#other-iocs-that-interface-with-cryosms" title="Link to this heading"></a></h2>
<p>If you write any other IOCs that interface with the CRYOSMS, please make note of them here. If
you use <a class="reference internal" href="#behind-the-scenes-pvs">Behind the scenes PVs</a> in them please also write a
justification of why your use-case is safe.</p>
<section id="hifimags">
<h3>HIFIMAGS<a class="headerlink" href="#hifimags" title="Link to this heading"></a></h3>
<p>Most of the magnet control on HIFI is done via the HIFIMAGS IOC, which is a series of db files
that get pointed to 4 CRYOSMS IOCS (main magnet, shims for x y and z axis) and a snl state
machine which controls when you are and aren’t allowed to change set points within HIFIMAGS.
There is an OPI that goes alongside this IOC, which helps scientists consolidate the main
numbers they care about from across the system in one place.</p>
</section>
<section id="hifi-s-zero-field-controller">
<h3>HIFI’s Zero Field Controller<a class="headerlink" href="#hifi-s-zero-field-controller" title="Link to this heading"></a></h3>
<p>HIFI also has a zero field IOC, which uses <a class="reference internal" href="#behind-the-scenes-pvs">Behind the scenes PVs</a> to
perform tiny, quick ramps on the shim coils to compensate for stray magnetic field. This is safe
because it is only the non-cryomagnet coils being used. Additionally, if this IOC is in use, the
individual CRYOSMS IOCs being linked to will lock all other input, and refuse to make heater
changes.</p>
</section>
</section>
</section>


           </div>
          </div>
          <footer><div class="rst-footer-buttons" role="navigation" aria-label="Footer">
        <a href="../Cryogenic-SMS-PSU.html" class="btn btn-neutral float-left" title="Cryosms PSU" accesskey="p" rel="prev"><span class="fa fa-arrow-circle-left" aria-hidden="true"></span> Previous</a>
        <a href="../Cryogenics-Ltd-Helium-Level-Gauge.html" class="btn btn-neutral float-right" title="Helium Level Gauge (Cryogenics Ltd)" accesskey="n" rel="next">Next <span class="fa fa-arrow-circle-right" aria-hidden="true"></span></a>
    </div>

  <hr/>

  <div role="contentinfo">
    <p>
      <span class="lastupdated">Last updated on Feb 27, 2026.
      </span></p>
  </div>

  Built with <a href="https://www.sphinx-doc.org/">Sphinx</a> using a
    <a href="https://github.com/readthedocs/sphinx_rtd_theme">theme</a>
    provided by <a href="https://readthedocs.org">Read the Docs</a>.
   

</footer>
        </div>
      </div>
    </section>
  </div>
  <script>
      jQuery(function () {
          SphinxRtdTheme.Navigation.enable(true);
      });
  </script> 

</body>
</html>